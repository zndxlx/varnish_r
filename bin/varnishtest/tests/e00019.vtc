varnishtest "Push corners in new ESI parser"

server s1 {
	rxreq
	txresp -nolen -hdr "Transfer-encoding: chunked"
	chunked {<1></esi:comment foo><1>}
	chunked {<2><esi:comment / ><esi:comment doo><2>}
	chunked {<3><esi:remove foo="bar"></esi:remove><3>}
	chunked {<4><esi:include src="foo"><esi:incl><4>}
	chunked {<H1><esi:remove>}
	chunkedlen 256
	chunked {</esi:remove></H1>}

	chunked {<H2><esi:remove>}
	chunkedlen 65536
	chunked {</esi:remove></H2>}

	chunked {<esi:comment/>}
	chunkedlen 256
	chunked {<esi:comment/>}
	chunkedlen 65536
	chunked {<esi:comment/>}

	chunked {<!--e}
	delay .4
	chunked {nd:comment>}

	chunkedlen 0
} -start

# The included object gets served from a different backend.
# This is to avoid a race between when a backend connection
# gets put up for reuse because of background fetches in
# Varnish 4
server s2 {
	rxreq
	expect req.url == "bar/foo"
	txresp -body {<INCL>}
} -start

varnish v1 -vcl+backend {
	sub vcl_backend_fetch {
		if (bereq.url != "bar") {
			set bereq.backend = s2;
		}
	}

	sub vcl_backend_response {
		if (bereq.url == "bar") {
			set beresp.do_esi = true;
		}
	}
} -start

varnish v1 -cliok "param.set debug +esi_chop"
varnish v1 -cliok "param.set debug +syncvsl"

client c1 {
	txreq  -url bar
	rxresp
	expect resp.status == 200
	expect resp.bodylen == 65856
} -run

varnish v1 -expect esi_errors == 5
varnish v1 -expect esi_warnings == 1
